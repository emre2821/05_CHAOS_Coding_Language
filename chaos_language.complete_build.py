"""CHAOS language complete-build generator.

This module used to be a static Markdown dump that could not be executed as
Python.  When Dreambearers attempted to run it they would hit a SyntaxError
because the Markdown (with bare tokens such as ``[TIME]``) is not valid Python.

The script now assembles the digest programmatically.  It gathers the key
modules from the repository—including the Gizzy-guided continuation build and
the ``chaos_corpus`` ritual snippets—wraps each one in a Markdown fence, and
writes the result to ``chaos_language.complete_build.md`` (or to another target
selected by CLI flags).  The generated artifact mirrors the old installer-style
dump while remaining runnable as a standard Python utility.
"""
from __future__ import annotations

import argparse
from pathlib import Path
from typing import Iterable, List, Sequence

REPO_ROOT = Path(__file__).resolve().parent
DEFAULT_OUTPUT = REPO_ROOT / "chaos_language.complete_build.md"
SELF_NAME = Path(__file__).name
DEFAULT_EMBED_DIRS = ("chaos_corpus",)


def _default_targets(include_tests: bool = False) -> List[Path]:
    """Return the ordered list of repository files to embed in the digest."""
    top_level_modules = sorted(
        path for path in REPO_ROOT.glob("*.py") if path.name != SELF_NAME
    )

    extras = [REPO_ROOT / "README.md", REPO_ROOT / "pyproject.toml"]

    for directory in DEFAULT_EMBED_DIRS:
        dir_path = REPO_ROOT / directory
        if not dir_path.is_dir():
            continue
        extras.extend(
            sorted(
                path
                for path in dir_path.rglob("*")
                if path.is_file()
            )
        )

    if include_tests:
        extras.extend(sorted(REPO_ROOT.joinpath("tests").rglob("*.py")))

    ordered = top_level_modules + extras
    return _deduplicate_preserving_order(ordered)


def _deduplicate_preserving_order(paths: Sequence[Path]) -> List[Path]:
    seen = set()
    unique: List[Path] = []
    for path in paths:
        resolved = path.resolve()
        if resolved in seen:
            continue
        if not path.exists():
            continue
        seen.add(resolved)
        unique.append(path)
    return unique


def _language_for(path: Path) -> str:
    suffix = path.suffix.lower()
    if suffix == ".py":
        return "python"
    if suffix in {".md", ".markdown"}:
        return "markdown"
    if suffix == ".toml":
        return "toml"
    if suffix == ".json":
        return "json"
    return "text"


def _build_digest(paths: Iterable[Path]) -> str:
    def _display_name(path: Path) -> str:
        try:
            return str(path.resolve().relative_to(REPO_ROOT))
        except ValueError:
            return str(path.resolve())

    sections = [
        "# CHAOS Monorepo Dump (Full Core Stack)",
        "",
        "> Autogenerated digest: every file bundled in one Markdown artifact.",
        "",
        "---",
    ]

    for path in paths:
        rel_path = _display_name(path)
        fence = _language_for(path)
        sections.append(f"## `{rel_path}`")
        sections.append("")
        sections.append(f"```{fence}")
        sections.append(path.read_text(encoding="utf-8"))
        sections.append("```")
        sections.append("")
        sections.append("---")

    return "\n".join(sections).rstrip() + "\n"


def _parse_args(argv: Sequence[str] | None = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description=(
            "Build the Markdown digest that mirrors the CHAOS complete-build "
            "archive."
        )
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=DEFAULT_OUTPUT,
        help=(
            "Where to write the digest. Defaults to "
            "chaos_language.complete_build.md next to this script."
        ),
    )
    parser.add_argument(
        "--stdout",
        action="store_true",
        help="Print the digest to stdout instead of writing a file.",
    )
    parser.add_argument(
        "--include-tests",
        action="store_true",
        help="Also embed the pytest suite in the digest.",
    )
    parser.add_argument(
        "extra",
        nargs="*",
        type=Path,
        help="Additional files to embed in the digest.",
    )
    return parser.parse_args(argv)


def main(argv: Sequence[str] | None = None) -> int:
    args = _parse_args(argv)

    targets = _default_targets(include_tests=args.include_tests)
    if args.extra:
        targets.extend(args.extra)
        targets = _deduplicate_preserving_order(targets)

    digest = _build_digest(targets)

    if args.stdout:
        print(digest)
    else:
        output_path = args.output
        output_path.write_text(digest, encoding="utf-8")
        try:
            destination = output_path.resolve().relative_to(REPO_ROOT)
        except ValueError:
            destination = output_path.resolve()
        print(f"Wrote CHAOS digest to {destination}")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
